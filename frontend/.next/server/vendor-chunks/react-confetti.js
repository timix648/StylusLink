"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-confetti";
exports.ids = ["vendor-chunks/react-confetti"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-confetti/dist/react-confetti.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/react-confetti/dist/react-confetti.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ReactConfetti)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var tween_functions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tween-functions */ \"(ssr)/./node_modules/tween-functions/index.js\");\n\n\n\n\nfunction degreesToRads(degrees) {\n    return (degrees * Math.PI) / 180;\n}\nfunction randomRange(min, max) {\n    return min + Math.random() * (max - min);\n}\nfunction randomInt(min, max) {\n    return Math.floor(min + Math.random() * (max - min + 1));\n}\n\nvar ParticleShape;\n(function (ParticleShape) {\n    ParticleShape[ParticleShape[\"Circle\"] = 0] = \"Circle\";\n    ParticleShape[ParticleShape[\"Square\"] = 1] = \"Square\";\n    ParticleShape[ParticleShape[\"Strip\"] = 2] = \"Strip\";\n})(ParticleShape || (ParticleShape = {}));\nvar RotationDirection;\n(function (RotationDirection) {\n    RotationDirection[RotationDirection[\"Positive\"] = 1] = \"Positive\";\n    RotationDirection[RotationDirection[\"Negative\"] = -1] = \"Negative\";\n})(RotationDirection || (RotationDirection = {}));\nconst DEFAULT_FRAME_TIME = 1000 / 60;\nclass Particle {\n    constructor(context, getOptions, x, y) {\n        this.getOptions = getOptions;\n        const { colors, initialVelocityX, initialVelocityY } = this.getOptions();\n        this.context = context;\n        this.x = x;\n        this.y = y;\n        this.w = randomRange(5, 20);\n        this.h = randomRange(5, 20);\n        this.radius = randomRange(5, 10);\n        this.vx =\n            typeof initialVelocityX === 'number'\n                ? randomRange(-initialVelocityX, initialVelocityX)\n                : randomRange(initialVelocityX.min, initialVelocityX.max);\n        this.vy =\n            typeof initialVelocityY === 'number'\n                ? randomRange(-initialVelocityY, 0)\n                : randomRange(initialVelocityY.min, initialVelocityY.max);\n        this.shape = randomInt(0, 2);\n        this.angle = degreesToRads(randomRange(0, 360));\n        this.angularSpin = randomRange(-0.2, 0.2);\n        this.color = colors[Math.floor(Math.random() * colors.length)];\n        this.rotateY = randomRange(0, 1);\n        this.rotationDirection = randomRange(0, 1)\n            ? RotationDirection.Positive\n            : RotationDirection.Negative;\n    }\n    update(elapsed) {\n        const { gravity, wind, friction, opacity, drawShape } = this.getOptions();\n        const frameTimeMultiplier = elapsed / DEFAULT_FRAME_TIME;\n        this.x += this.vx * frameTimeMultiplier;\n        this.y += this.vy * frameTimeMultiplier;\n        this.vy += gravity * frameTimeMultiplier;\n        this.vx += wind * frameTimeMultiplier;\n        this.vx *= friction ** frameTimeMultiplier;\n        this.vy *= friction ** frameTimeMultiplier;\n        if (this.rotateY >= 1 &&\n            this.rotationDirection === RotationDirection.Positive) {\n            this.rotationDirection = RotationDirection.Negative;\n        }\n        else if (this.rotateY <= -1 &&\n            this.rotationDirection === RotationDirection.Negative) {\n            this.rotationDirection = RotationDirection.Positive;\n        }\n        const rotateDelta = 0.1 * this.rotationDirection * frameTimeMultiplier;\n        this.rotateY += rotateDelta;\n        this.angle += this.angularSpin;\n        this.context.save();\n        this.context.translate(this.x, this.y);\n        this.context.rotate(this.angle);\n        this.context.scale(1, this.rotateY);\n        this.context.rotate(this.angle);\n        this.context.beginPath();\n        this.context.fillStyle = this.color;\n        this.context.strokeStyle = this.color;\n        this.context.globalAlpha = opacity;\n        this.context.lineCap = 'round';\n        this.context.lineWidth = 2;\n        if (drawShape && typeof drawShape === 'function') {\n            drawShape.call(this, this.context);\n        }\n        else {\n            switch (this.shape) {\n                case ParticleShape.Circle: {\n                    this.context.beginPath();\n                    this.context.arc(0, 0, this.radius, 0, 2 * Math.PI);\n                    this.context.fill();\n                    break;\n                }\n                case ParticleShape.Square: {\n                    this.context.fillRect(-this.w / 2, -this.h / 2, this.w, this.h);\n                    break;\n                }\n                case ParticleShape.Strip: {\n                    this.context.fillRect(-this.w / 6, -this.h / 2, this.w / 3, this.h);\n                    break;\n                }\n            }\n        }\n        this.context.closePath();\n        this.context.restore();\n    }\n}\n\nclass ParticleGenerator {\n    constructor(canvas, getOptions) {\n        this.x = 0;\n        this.y = 0;\n        this.w = 0;\n        this.h = 0;\n        this.lastNumberOfPieces = 0;\n        this.tweenProgress = 0;\n        this.tweenFrom = 0;\n        this.particles = [];\n        this.particlesGenerated = 0;\n        this.removeParticleAt = (i) => {\n            this.particles.splice(i, 1);\n        };\n        this.getParticle = () => {\n            const newParticleX = randomRange(this.x, this.w + this.x);\n            const newParticleY = randomRange(this.y, this.h + this.y);\n            return new Particle(this.context, this.getOptions, newParticleX, newParticleY);\n        };\n        this.animate = (elapsed) => {\n            const { canvas, context, particlesGenerated, lastNumberOfPieces } = this;\n            const { run, recycle, numberOfPieces, debug, tweenFunction, tweenDuration, } = this.getOptions();\n            if (!run) {\n                return false;\n            }\n            const nP = this.particles.length;\n            const activeCount = recycle ? nP : particlesGenerated;\n            // Initial population\n            if (activeCount < numberOfPieces) {\n                // Use the numberOfPieces prop as a key to reset the easing timing\n                if (lastNumberOfPieces !== numberOfPieces) {\n                    this.tweenProgress = 0;\n                    this.tweenFrom = activeCount;\n                    this.lastNumberOfPieces = numberOfPieces;\n                }\n                // Clamp tweenProgress between 0 and tweenDuration\n                this.tweenProgress = Math.min(tweenDuration, Math.max(0, this.tweenProgress + elapsed));\n                const tweenedVal = tweenFunction(this.tweenProgress, this.tweenFrom, numberOfPieces, tweenDuration);\n                const numToAdd = Math.round(tweenedVal - activeCount);\n                for (let i = 0; i < numToAdd; i++) {\n                    this.particles.push(this.getParticle());\n                }\n                this.particlesGenerated += numToAdd;\n            }\n            if (debug) {\n                // Draw debug text\n                context.font = '12px sans-serif';\n                context.fillStyle = '#333';\n                context.textAlign = 'right';\n                context.fillText(`Particles: ${nP}`, canvas.width - 10, canvas.height - 20);\n            }\n            // Maintain the population, iterating backwards to prevent issues when removing particles\n            for (let i = this.particles.length - 1; i >= 0; i--) {\n                const p = this.particles[i];\n                // Update each particle's position\n                p.update(elapsed);\n                // Prune the off-canvas particles\n                if (p.y > canvas.height ||\n                    p.y < -100 ||\n                    p.x > canvas.width + 100 ||\n                    p.x < -100) {\n                    if (recycle && activeCount <= numberOfPieces) {\n                        // Replace the particle with a brand new one\n                        this.particles[i] = this.getParticle();\n                    }\n                    else {\n                        this.removeParticleAt(i);\n                    }\n                }\n            }\n            return nP > 0 || activeCount < numberOfPieces;\n        };\n        this.canvas = canvas;\n        const ctx = this.canvas.getContext('2d');\n        if (!ctx) {\n            throw new Error('Could not get canvas context');\n        }\n        this.context = ctx;\n        this.getOptions = getOptions;\n    }\n}\n\nconst confettiDefaults = {\n    width: typeof window !== 'undefined' ? window.innerWidth : 300,\n    height: typeof window !== 'undefined' ? window.innerHeight : 200,\n    numberOfPieces: 200,\n    friction: 0.99,\n    wind: 0,\n    gravity: 0.1,\n    initialVelocityX: 4,\n    initialVelocityY: 10,\n    colors: [\n        '#f44336',\n        '#e91e63',\n        '#9c27b0',\n        '#673ab7',\n        '#3f51b5',\n        '#2196f3',\n        '#03a9f4',\n        '#00bcd4',\n        '#009688',\n        '#4CAF50',\n        '#8BC34A',\n        '#CDDC39',\n        '#FFEB3B',\n        '#FFC107',\n        '#FF9800',\n        '#FF5722',\n        '#795548',\n    ],\n    opacity: 1.0,\n    debug: false,\n    tweenFunction: tween_functions__WEBPACK_IMPORTED_MODULE_2__.easeInOutQuad,\n    tweenDuration: 5000,\n    recycle: true,\n    run: true,\n};\nclass Confetti {\n    constructor(canvas, opts) {\n        this.lastFrameTime = 0;\n        this.setOptionsWithDefaults = (opts) => {\n            const computedConfettiDefaults = {\n                confettiSource: {\n                    x: 0,\n                    y: 0,\n                    w: this.canvas.width,\n                    h: 0,\n                },\n            };\n            this._options = {\n                ...computedConfettiDefaults,\n                ...confettiDefaults,\n                ...opts,\n            };\n            Object.assign(this, opts.confettiSource);\n        };\n        this.update = (timestamp = 0) => {\n            const { options: { run, onConfettiComplete, frameRate }, canvas, context, } = this;\n            // Cap elapsed time to 50ms to prevent large time steps\n            const elapsed = Math.min(timestamp - this.lastFrameTime, 50);\n            // Throttle the frame rate if set\n            if (frameRate && elapsed < 1000 / frameRate) {\n                this.rafId = requestAnimationFrame(this.update);\n                return;\n            }\n            this.lastFrameTime = timestamp - (frameRate ? elapsed % frameRate : 0);\n            if (run) {\n                context.fillStyle = 'white';\n                context.clearRect(0, 0, canvas.width, canvas.height);\n            }\n            if (this.generator.animate(elapsed)) {\n                this.rafId = requestAnimationFrame(this.update);\n            }\n            else {\n                if (onConfettiComplete &&\n                    typeof onConfettiComplete === 'function' &&\n                    this.generator.particlesGenerated > 0) {\n                    onConfettiComplete.call(this, this);\n                }\n                this._options.run = false;\n            }\n        };\n        this.reset = () => {\n            if (this.generator && this.generator.particlesGenerated > 0) {\n                this.generator.particlesGenerated = 0;\n                this.generator.particles = [];\n                this.generator.lastNumberOfPieces = 0;\n            }\n        };\n        this.stop = () => {\n            this.options = { run: false };\n            if (this.rafId) {\n                cancelAnimationFrame(this.rafId);\n                this.rafId = undefined;\n            }\n        };\n        this.canvas = canvas;\n        const ctx = this.canvas.getContext('2d');\n        if (!ctx) {\n            throw new Error('Could not get canvas context');\n        }\n        this.context = ctx;\n        this.generator = new ParticleGenerator(this.canvas, () => this.options);\n        this.options = opts;\n        this.update();\n    }\n    get options() {\n        return this._options;\n    }\n    set options(opts) {\n        const lastRunState = this._options?.run;\n        const lastRecycleState = this._options?.recycle;\n        this.setOptionsWithDefaults(opts);\n        if (this.generator) {\n            Object.assign(this.generator, this.options.confettiSource);\n            if (typeof opts.recycle === 'boolean' &&\n                opts.recycle &&\n                lastRecycleState === false) {\n                this.generator.lastNumberOfPieces = this.generator.particles.length;\n            }\n        }\n        if (typeof opts.run === 'boolean' && opts.run && lastRunState === false) {\n            this.update();\n        }\n    }\n}\n\nconst ref = react__WEBPACK_IMPORTED_MODULE_1__.createRef();\nclass ReactConfettiInternal extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n    constructor(props) {\n        super(props);\n        this.canvas = react__WEBPACK_IMPORTED_MODULE_1__.createRef();\n        this.canvas = props.canvasRef || ref;\n    }\n    componentDidMount() {\n        if (this.canvas.current) {\n            const opts = extractCanvasProps(this.props)[0];\n            this.confetti = new Confetti(this.canvas.current, opts);\n        }\n    }\n    componentDidUpdate() {\n        const confettiOptions = extractCanvasProps(this.props)[0];\n        if (this.confetti) {\n            this.confetti.options = confettiOptions;\n        }\n    }\n    componentWillUnmount() {\n        if (this.confetti) {\n            this.confetti.stop();\n        }\n        this.confetti = undefined;\n    }\n    render() {\n        const [confettiOptions, passedProps] = extractCanvasProps(this.props);\n        const canvasStyles = {\n            zIndex: 2,\n            position: 'absolute',\n            pointerEvents: 'none',\n            top: 0,\n            left: 0,\n            bottom: 0,\n            right: 0,\n            ...passedProps.style,\n        };\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"canvas\", { width: confettiOptions.width, height: confettiOptions.height, ref: this.canvas, ...passedProps, style: canvasStyles }));\n    }\n}\nReactConfettiInternal.defaultProps = {\n    ...confettiDefaults,\n};\nReactConfettiInternal.displayName = 'ReactConfetti';\nfunction extractCanvasProps(props) {\n    const confettiOptions = {};\n    const refs = {};\n    const rest = {};\n    const confettiOptionKeys = [\n        ...Object.keys(confettiDefaults),\n        'confettiSource',\n        'drawShape',\n        'onConfettiComplete',\n        'frameRate',\n    ];\n    const refProps = ['canvasRef'];\n    for (const prop in props) {\n        const val = props[prop];\n        if (confettiOptionKeys.includes(prop)) {\n            confettiOptions[prop] = val;\n        }\n        else if (refProps.includes(prop)) {\n            refProps[prop] = val;\n        }\n        else {\n            rest[prop] = val;\n        }\n    }\n    return [confettiOptions, rest, refs];\n}\nconst ReactConfetti = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, ref) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ReactConfettiInternal, { canvasRef: ref, ...props }));\n\n\n//# sourceMappingURL=react-confetti.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY29uZmV0dGkvZGlzdC9yZWFjdC1jb25mZXR0aS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3QztBQUNkO0FBQ2dCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkNBQTZDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBOEM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQTBEO0FBQzlFLG9CQUFvQixxRUFBcUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxHQUFHO0FBQ2xEO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVcsb0NBQW9DLHFCQUFxQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSw0Q0FBZTtBQUMzQixvQ0FBb0MsNENBQWU7QUFDbkQ7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFHLGFBQWEscUhBQXFIO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkNBQWdCLGlCQUFpQixzREFBRywwQkFBMEIsMEJBQTBCOztBQUUxRTtBQUNwQyIsInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvU3R5bHVzTGluay9mcm9udGVuZC9ub2RlX21vZHVsZXMvcmVhY3QtY29uZmV0dGkvZGlzdC9yZWFjdC1jb25mZXR0aS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIHR3ZWVucyBmcm9tICd0d2Vlbi1mdW5jdGlvbnMnO1xuXG5mdW5jdGlvbiBkZWdyZWVzVG9SYWRzKGRlZ3JlZXMpIHtcbiAgICByZXR1cm4gKGRlZ3JlZXMgKiBNYXRoLlBJKSAvIDE4MDtcbn1cbmZ1bmN0aW9uIHJhbmRvbVJhbmdlKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIG1pbiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKTtcbn1cbmZ1bmN0aW9uIHJhbmRvbUludChtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1pbiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xufVxuXG52YXIgUGFydGljbGVTaGFwZTtcbihmdW5jdGlvbiAoUGFydGljbGVTaGFwZSkge1xuICAgIFBhcnRpY2xlU2hhcGVbUGFydGljbGVTaGFwZVtcIkNpcmNsZVwiXSA9IDBdID0gXCJDaXJjbGVcIjtcbiAgICBQYXJ0aWNsZVNoYXBlW1BhcnRpY2xlU2hhcGVbXCJTcXVhcmVcIl0gPSAxXSA9IFwiU3F1YXJlXCI7XG4gICAgUGFydGljbGVTaGFwZVtQYXJ0aWNsZVNoYXBlW1wiU3RyaXBcIl0gPSAyXSA9IFwiU3RyaXBcIjtcbn0pKFBhcnRpY2xlU2hhcGUgfHwgKFBhcnRpY2xlU2hhcGUgPSB7fSkpO1xudmFyIFJvdGF0aW9uRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChSb3RhdGlvbkRpcmVjdGlvbikge1xuICAgIFJvdGF0aW9uRGlyZWN0aW9uW1JvdGF0aW9uRGlyZWN0aW9uW1wiUG9zaXRpdmVcIl0gPSAxXSA9IFwiUG9zaXRpdmVcIjtcbiAgICBSb3RhdGlvbkRpcmVjdGlvbltSb3RhdGlvbkRpcmVjdGlvbltcIk5lZ2F0aXZlXCJdID0gLTFdID0gXCJOZWdhdGl2ZVwiO1xufSkoUm90YXRpb25EaXJlY3Rpb24gfHwgKFJvdGF0aW9uRGlyZWN0aW9uID0ge30pKTtcbmNvbnN0IERFRkFVTFRfRlJBTUVfVElNRSA9IDEwMDAgLyA2MDtcbmNsYXNzIFBhcnRpY2xlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBnZXRPcHRpb25zLCB4LCB5KSB7XG4gICAgICAgIHRoaXMuZ2V0T3B0aW9ucyA9IGdldE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgY29sb3JzLCBpbml0aWFsVmVsb2NpdHlYLCBpbml0aWFsVmVsb2NpdHlZIH0gPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53ID0gcmFuZG9tUmFuZ2UoNSwgMjApO1xuICAgICAgICB0aGlzLmggPSByYW5kb21SYW5nZSg1LCAyMCk7XG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFuZG9tUmFuZ2UoNSwgMTApO1xuICAgICAgICB0aGlzLnZ4ID1cbiAgICAgICAgICAgIHR5cGVvZiBpbml0aWFsVmVsb2NpdHlYID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgID8gcmFuZG9tUmFuZ2UoLWluaXRpYWxWZWxvY2l0eVgsIGluaXRpYWxWZWxvY2l0eVgpXG4gICAgICAgICAgICAgICAgOiByYW5kb21SYW5nZShpbml0aWFsVmVsb2NpdHlYLm1pbiwgaW5pdGlhbFZlbG9jaXR5WC5tYXgpO1xuICAgICAgICB0aGlzLnZ5ID1cbiAgICAgICAgICAgIHR5cGVvZiBpbml0aWFsVmVsb2NpdHlZID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgID8gcmFuZG9tUmFuZ2UoLWluaXRpYWxWZWxvY2l0eVksIDApXG4gICAgICAgICAgICAgICAgOiByYW5kb21SYW5nZShpbml0aWFsVmVsb2NpdHlZLm1pbiwgaW5pdGlhbFZlbG9jaXR5WS5tYXgpO1xuICAgICAgICB0aGlzLnNoYXBlID0gcmFuZG9tSW50KDAsIDIpO1xuICAgICAgICB0aGlzLmFuZ2xlID0gZGVncmVlc1RvUmFkcyhyYW5kb21SYW5nZSgwLCAzNjApKTtcbiAgICAgICAgdGhpcy5hbmd1bGFyU3BpbiA9IHJhbmRvbVJhbmdlKC0wLjIsIDAuMik7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY29sb3JzLmxlbmd0aCldO1xuICAgICAgICB0aGlzLnJvdGF0ZVkgPSByYW5kb21SYW5nZSgwLCAxKTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbkRpcmVjdGlvbiA9IHJhbmRvbVJhbmdlKDAsIDEpXG4gICAgICAgICAgICA/IFJvdGF0aW9uRGlyZWN0aW9uLlBvc2l0aXZlXG4gICAgICAgICAgICA6IFJvdGF0aW9uRGlyZWN0aW9uLk5lZ2F0aXZlO1xuICAgIH1cbiAgICB1cGRhdGUoZWxhcHNlZCkge1xuICAgICAgICBjb25zdCB7IGdyYXZpdHksIHdpbmQsIGZyaWN0aW9uLCBvcGFjaXR5LCBkcmF3U2hhcGUgfSA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgICBjb25zdCBmcmFtZVRpbWVNdWx0aXBsaWVyID0gZWxhcHNlZCAvIERFRkFVTFRfRlJBTUVfVElNRTtcbiAgICAgICAgdGhpcy54ICs9IHRoaXMudnggKiBmcmFtZVRpbWVNdWx0aXBsaWVyO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy52eSAqIGZyYW1lVGltZU11bHRpcGxpZXI7XG4gICAgICAgIHRoaXMudnkgKz0gZ3Jhdml0eSAqIGZyYW1lVGltZU11bHRpcGxpZXI7XG4gICAgICAgIHRoaXMudnggKz0gd2luZCAqIGZyYW1lVGltZU11bHRpcGxpZXI7XG4gICAgICAgIHRoaXMudnggKj0gZnJpY3Rpb24gKiogZnJhbWVUaW1lTXVsdGlwbGllcjtcbiAgICAgICAgdGhpcy52eSAqPSBmcmljdGlvbiAqKiBmcmFtZVRpbWVNdWx0aXBsaWVyO1xuICAgICAgICBpZiAodGhpcy5yb3RhdGVZID49IDEgJiZcbiAgICAgICAgICAgIHRoaXMucm90YXRpb25EaXJlY3Rpb24gPT09IFJvdGF0aW9uRGlyZWN0aW9uLlBvc2l0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uRGlyZWN0aW9uID0gUm90YXRpb25EaXJlY3Rpb24uTmVnYXRpdmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5yb3RhdGVZIDw9IC0xICYmXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uRGlyZWN0aW9uID09PSBSb3RhdGlvbkRpcmVjdGlvbi5OZWdhdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbkRpcmVjdGlvbiA9IFJvdGF0aW9uRGlyZWN0aW9uLlBvc2l0aXZlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdGF0ZURlbHRhID0gMC4xICogdGhpcy5yb3RhdGlvbkRpcmVjdGlvbiAqIGZyYW1lVGltZU11bHRpcGxpZXI7XG4gICAgICAgIHRoaXMucm90YXRlWSArPSByb3RhdGVEZWx0YTtcbiAgICAgICAgdGhpcy5hbmdsZSArPSB0aGlzLmFuZ3VsYXJTcGluO1xuICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xuICAgICAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJvdGF0ZSh0aGlzLmFuZ2xlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnNjYWxlKDEsIHRoaXMucm90YXRlWSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5yb3RhdGUodGhpcy5hbmdsZSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICAgIHRoaXMuY29udGV4dC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICAgIHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICAgIHRoaXMuY29udGV4dC5saW5lQ2FwID0gJ3JvdW5kJztcbiAgICAgICAgdGhpcy5jb250ZXh0LmxpbmVXaWR0aCA9IDI7XG4gICAgICAgIGlmIChkcmF3U2hhcGUgJiYgdHlwZW9mIGRyYXdTaGFwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZHJhd1NoYXBlLmNhbGwodGhpcywgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zaGFwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgUGFydGljbGVTaGFwZS5DaXJjbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYXJjKDAsIDAsIHRoaXMucmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFBhcnRpY2xlU2hhcGUuU3F1YXJlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsUmVjdCgtdGhpcy53IC8gMiwgLXRoaXMuaCAvIDIsIHRoaXMudywgdGhpcy5oKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgUGFydGljbGVTaGFwZS5TdHJpcDoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoLXRoaXMudyAvIDYsIC10aGlzLmggLyAyLCB0aGlzLncgLyAzLCB0aGlzLmgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbn1cblxuY2xhc3MgUGFydGljbGVHZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhbnZhcywgZ2V0T3B0aW9ucykge1xuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICB0aGlzLncgPSAwO1xuICAgICAgICB0aGlzLmggPSAwO1xuICAgICAgICB0aGlzLmxhc3ROdW1iZXJPZlBpZWNlcyA9IDA7XG4gICAgICAgIHRoaXMudHdlZW5Qcm9ncmVzcyA9IDA7XG4gICAgICAgIHRoaXMudHdlZW5Gcm9tID0gMDtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXNHZW5lcmF0ZWQgPSAwO1xuICAgICAgICB0aGlzLnJlbW92ZVBhcnRpY2xlQXQgPSAoaSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFBhcnRpY2xlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3UGFydGljbGVYID0gcmFuZG9tUmFuZ2UodGhpcy54LCB0aGlzLncgKyB0aGlzLngpO1xuICAgICAgICAgICAgY29uc3QgbmV3UGFydGljbGVZID0gcmFuZG9tUmFuZ2UodGhpcy55LCB0aGlzLmggKyB0aGlzLnkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJ0aWNsZSh0aGlzLmNvbnRleHQsIHRoaXMuZ2V0T3B0aW9ucywgbmV3UGFydGljbGVYLCBuZXdQYXJ0aWNsZVkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFuaW1hdGUgPSAoZWxhcHNlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjYW52YXMsIGNvbnRleHQsIHBhcnRpY2xlc0dlbmVyYXRlZCwgbGFzdE51bWJlck9mUGllY2VzIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBydW4sIHJlY3ljbGUsIG51bWJlck9mUGllY2VzLCBkZWJ1ZywgdHdlZW5GdW5jdGlvbiwgdHdlZW5EdXJhdGlvbiwgfSA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgaWYgKCFydW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuUCA9IHRoaXMucGFydGljbGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUNvdW50ID0gcmVjeWNsZSA/IG5QIDogcGFydGljbGVzR2VuZXJhdGVkO1xuICAgICAgICAgICAgLy8gSW5pdGlhbCBwb3B1bGF0aW9uXG4gICAgICAgICAgICBpZiAoYWN0aXZlQ291bnQgPCBudW1iZXJPZlBpZWNlcykge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgbnVtYmVyT2ZQaWVjZXMgcHJvcCBhcyBhIGtleSB0byByZXNldCB0aGUgZWFzaW5nIHRpbWluZ1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TnVtYmVyT2ZQaWVjZXMgIT09IG51bWJlck9mUGllY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHdlZW5Qcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHdlZW5Gcm9tID0gYWN0aXZlQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdE51bWJlck9mUGllY2VzID0gbnVtYmVyT2ZQaWVjZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENsYW1wIHR3ZWVuUHJvZ3Jlc3MgYmV0d2VlbiAwIGFuZCB0d2VlbkR1cmF0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy50d2VlblByb2dyZXNzID0gTWF0aC5taW4odHdlZW5EdXJhdGlvbiwgTWF0aC5tYXgoMCwgdGhpcy50d2VlblByb2dyZXNzICsgZWxhcHNlZCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR3ZWVuZWRWYWwgPSB0d2VlbkZ1bmN0aW9uKHRoaXMudHdlZW5Qcm9ncmVzcywgdGhpcy50d2VlbkZyb20sIG51bWJlck9mUGllY2VzLCB0d2VlbkR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1Ub0FkZCA9IE1hdGgucm91bmQodHdlZW5lZFZhbCAtIGFjdGl2ZUNvdW50KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRvQWRkOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMucHVzaCh0aGlzLmdldFBhcnRpY2xlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlc0dlbmVyYXRlZCArPSBudW1Ub0FkZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgIC8vIERyYXcgZGVidWcgdGV4dFxuICAgICAgICAgICAgICAgIGNvbnRleHQuZm9udCA9ICcxMnB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMzMzMnO1xuICAgICAgICAgICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGBQYXJ0aWNsZXM6ICR7blB9YCwgY2FudmFzLndpZHRoIC0gMTAsIGNhbnZhcy5oZWlnaHQgLSAyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWludGFpbiB0aGUgcG9wdWxhdGlvbiwgaXRlcmF0aW5nIGJhY2t3YXJkcyB0byBwcmV2ZW50IGlzc3VlcyB3aGVuIHJlbW92aW5nIHBhcnRpY2xlc1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMucGFydGljbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMucGFydGljbGVzW2ldO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBlYWNoIHBhcnRpY2xlJ3MgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBwLnVwZGF0ZShlbGFwc2VkKTtcbiAgICAgICAgICAgICAgICAvLyBQcnVuZSB0aGUgb2ZmLWNhbnZhcyBwYXJ0aWNsZXNcbiAgICAgICAgICAgICAgICBpZiAocC55ID4gY2FudmFzLmhlaWdodCB8fFxuICAgICAgICAgICAgICAgICAgICBwLnkgPCAtMTAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHAueCA+IGNhbnZhcy53aWR0aCArIDEwMCB8fFxuICAgICAgICAgICAgICAgICAgICBwLnggPCAtMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN5Y2xlICYmIGFjdGl2ZUNvdW50IDw9IG51bWJlck9mUGllY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBwYXJ0aWNsZSB3aXRoIGEgYnJhbmQgbmV3IG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXNbaV0gPSB0aGlzLmdldFBhcnRpY2xlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVBhcnRpY2xlQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gblAgPiAwIHx8IGFjdGl2ZUNvdW50IDwgbnVtYmVyT2ZQaWVjZXM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY3R4O1xuICAgICAgICB0aGlzLmdldE9wdGlvbnMgPSBnZXRPcHRpb25zO1xuICAgIH1cbn1cblxuY29uc3QgY29uZmV0dGlEZWZhdWx0cyA9IHtcbiAgICB3aWR0aDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IDMwMCxcbiAgICBoZWlnaHQ6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmlubmVySGVpZ2h0IDogMjAwLFxuICAgIG51bWJlck9mUGllY2VzOiAyMDAsXG4gICAgZnJpY3Rpb246IDAuOTksXG4gICAgd2luZDogMCxcbiAgICBncmF2aXR5OiAwLjEsXG4gICAgaW5pdGlhbFZlbG9jaXR5WDogNCxcbiAgICBpbml0aWFsVmVsb2NpdHlZOiAxMCxcbiAgICBjb2xvcnM6IFtcbiAgICAgICAgJyNmNDQzMzYnLFxuICAgICAgICAnI2U5MWU2MycsXG4gICAgICAgICcjOWMyN2IwJyxcbiAgICAgICAgJyM2NzNhYjcnLFxuICAgICAgICAnIzNmNTFiNScsXG4gICAgICAgICcjMjE5NmYzJyxcbiAgICAgICAgJyMwM2E5ZjQnLFxuICAgICAgICAnIzAwYmNkNCcsXG4gICAgICAgICcjMDA5Njg4JyxcbiAgICAgICAgJyM0Q0FGNTAnLFxuICAgICAgICAnIzhCQzM0QScsXG4gICAgICAgICcjQ0REQzM5JyxcbiAgICAgICAgJyNGRkVCM0InLFxuICAgICAgICAnI0ZGQzEwNycsXG4gICAgICAgICcjRkY5ODAwJyxcbiAgICAgICAgJyNGRjU3MjInLFxuICAgICAgICAnIzc5NTU0OCcsXG4gICAgXSxcbiAgICBvcGFjaXR5OiAxLjAsXG4gICAgZGVidWc6IGZhbHNlLFxuICAgIHR3ZWVuRnVuY3Rpb246IHR3ZWVucy5lYXNlSW5PdXRRdWFkLFxuICAgIHR3ZWVuRHVyYXRpb246IDUwMDAsXG4gICAgcmVjeWNsZTogdHJ1ZSxcbiAgICBydW46IHRydWUsXG59O1xuY2xhc3MgQ29uZmV0dGkge1xuICAgIGNvbnN0cnVjdG9yKGNhbnZhcywgb3B0cykge1xuICAgICAgICB0aGlzLmxhc3RGcmFtZVRpbWUgPSAwO1xuICAgICAgICB0aGlzLnNldE9wdGlvbnNXaXRoRGVmYXVsdHMgPSAob3B0cykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tcHV0ZWRDb25mZXR0aURlZmF1bHRzID0ge1xuICAgICAgICAgICAgICAgIGNvbmZldHRpU291cmNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHc6IHRoaXMuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoOiAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAuLi5jb21wdXRlZENvbmZldHRpRGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgLi4uY29uZmV0dGlEZWZhdWx0cyxcbiAgICAgICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0cy5jb25mZXR0aVNvdXJjZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlID0gKHRpbWVzdGFtcCA9IDApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9uczogeyBydW4sIG9uQ29uZmV0dGlDb21wbGV0ZSwgZnJhbWVSYXRlIH0sIGNhbnZhcywgY29udGV4dCwgfSA9IHRoaXM7XG4gICAgICAgICAgICAvLyBDYXAgZWxhcHNlZCB0aW1lIHRvIDUwbXMgdG8gcHJldmVudCBsYXJnZSB0aW1lIHN0ZXBzXG4gICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gTWF0aC5taW4odGltZXN0YW1wIC0gdGhpcy5sYXN0RnJhbWVUaW1lLCA1MCk7XG4gICAgICAgICAgICAvLyBUaHJvdHRsZSB0aGUgZnJhbWUgcmF0ZSBpZiBzZXRcbiAgICAgICAgICAgIGlmIChmcmFtZVJhdGUgJiYgZWxhcHNlZCA8IDEwMDAgLyBmcmFtZVJhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxhc3RGcmFtZVRpbWUgPSB0aW1lc3RhbXAgLSAoZnJhbWVSYXRlID8gZWxhcHNlZCAlIGZyYW1lUmF0ZSA6IDApO1xuICAgICAgICAgICAgaWYgKHJ1bikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdG9yLmFuaW1hdGUoZWxhcHNlZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvbkNvbmZldHRpQ29tcGxldGUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG9uQ29uZmV0dGlDb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRvci5wYXJ0aWNsZXNHZW5lcmF0ZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ29uZmV0dGlDb21wbGV0ZS5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLnJ1biA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlc2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdG9yICYmIHRoaXMuZ2VuZXJhdG9yLnBhcnRpY2xlc0dlbmVyYXRlZCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRvci5wYXJ0aWNsZXNHZW5lcmF0ZWQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yLnBhcnRpY2xlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yLmxhc3ROdW1iZXJPZlBpZWNlcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RvcCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHsgcnVuOiBmYWxzZSB9O1xuICAgICAgICAgICAgaWYgKHRoaXMucmFmSWQpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZklkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGN0eDtcbiAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBuZXcgUGFydGljbGVHZW5lcmF0b3IodGhpcy5jYW52YXMsICgpID0+IHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdHM7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9XG4gICAgc2V0IG9wdGlvbnMob3B0cykge1xuICAgICAgICBjb25zdCBsYXN0UnVuU3RhdGUgPSB0aGlzLl9vcHRpb25zPy5ydW47XG4gICAgICAgIGNvbnN0IGxhc3RSZWN5Y2xlU3RhdGUgPSB0aGlzLl9vcHRpb25zPy5yZWN5Y2xlO1xuICAgICAgICB0aGlzLnNldE9wdGlvbnNXaXRoRGVmYXVsdHMob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmdlbmVyYXRvcikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmdlbmVyYXRvciwgdGhpcy5vcHRpb25zLmNvbmZldHRpU291cmNlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5yZWN5Y2xlID09PSAnYm9vbGVhbicgJiZcbiAgICAgICAgICAgICAgICBvcHRzLnJlY3ljbGUgJiZcbiAgICAgICAgICAgICAgICBsYXN0UmVjeWNsZVN0YXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yLmxhc3ROdW1iZXJPZlBpZWNlcyA9IHRoaXMuZ2VuZXJhdG9yLnBhcnRpY2xlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLnJ1biA9PT0gJ2Jvb2xlYW4nICYmIG9wdHMucnVuICYmIGxhc3RSdW5TdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuY2xhc3MgUmVhY3RDb25mZXR0aUludGVybmFsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gcHJvcHMuY2FudmFzUmVmIHx8IHJlZjtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbnZhcy5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gZXh0cmFjdENhbnZhc1Byb3BzKHRoaXMucHJvcHMpWzBdO1xuICAgICAgICAgICAgdGhpcy5jb25mZXR0aSA9IG5ldyBDb25mZXR0aSh0aGlzLmNhbnZhcy5jdXJyZW50LCBvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IGNvbmZldHRpT3B0aW9ucyA9IGV4dHJhY3RDYW52YXNQcm9wcyh0aGlzLnByb3BzKVswXTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmV0dGkpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmV0dGkub3B0aW9ucyA9IGNvbmZldHRpT3B0aW9ucztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmV0dGkpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmV0dGkuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmV0dGkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgW2NvbmZldHRpT3B0aW9ucywgcGFzc2VkUHJvcHNdID0gZXh0cmFjdENhbnZhc1Byb3BzKHRoaXMucHJvcHMpO1xuICAgICAgICBjb25zdCBjYW52YXNTdHlsZXMgPSB7XG4gICAgICAgICAgICB6SW5kZXg6IDIsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgIC4uLnBhc3NlZFByb3BzLnN0eWxlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKGpzeChcImNhbnZhc1wiLCB7IHdpZHRoOiBjb25mZXR0aU9wdGlvbnMud2lkdGgsIGhlaWdodDogY29uZmV0dGlPcHRpb25zLmhlaWdodCwgcmVmOiB0aGlzLmNhbnZhcywgLi4ucGFzc2VkUHJvcHMsIHN0eWxlOiBjYW52YXNTdHlsZXMgfSkpO1xuICAgIH1cbn1cblJlYWN0Q29uZmV0dGlJbnRlcm5hbC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgLi4uY29uZmV0dGlEZWZhdWx0cyxcbn07XG5SZWFjdENvbmZldHRpSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnUmVhY3RDb25mZXR0aSc7XG5mdW5jdGlvbiBleHRyYWN0Q2FudmFzUHJvcHMocHJvcHMpIHtcbiAgICBjb25zdCBjb25mZXR0aU9wdGlvbnMgPSB7fTtcbiAgICBjb25zdCByZWZzID0ge307XG4gICAgY29uc3QgcmVzdCA9IHt9O1xuICAgIGNvbnN0IGNvbmZldHRpT3B0aW9uS2V5cyA9IFtcbiAgICAgICAgLi4uT2JqZWN0LmtleXMoY29uZmV0dGlEZWZhdWx0cyksXG4gICAgICAgICdjb25mZXR0aVNvdXJjZScsXG4gICAgICAgICdkcmF3U2hhcGUnLFxuICAgICAgICAnb25Db25mZXR0aUNvbXBsZXRlJyxcbiAgICAgICAgJ2ZyYW1lUmF0ZScsXG4gICAgXTtcbiAgICBjb25zdCByZWZQcm9wcyA9IFsnY2FudmFzUmVmJ107XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHByb3BzW3Byb3BdO1xuICAgICAgICBpZiAoY29uZmV0dGlPcHRpb25LZXlzLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgICBjb25mZXR0aU9wdGlvbnNbcHJvcF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVmUHJvcHMuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgICAgIHJlZlByb3BzW3Byb3BdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdFtwcm9wXSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2NvbmZldHRpT3B0aW9ucywgcmVzdCwgcmVmc107XG59XG5jb25zdCBSZWFjdENvbmZldHRpID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ganN4KFJlYWN0Q29uZmV0dGlJbnRlcm5hbCwgeyBjYW52YXNSZWY6IHJlZiwgLi4ucHJvcHMgfSkpO1xuXG5leHBvcnQgeyBSZWFjdENvbmZldHRpIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LWNvbmZldHRpLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-confetti/dist/react-confetti.mjs\n");

/***/ })

};
;